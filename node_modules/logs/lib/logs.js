"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const adaptable_1 = require("./adaptable");
const utils_1 = require("./utils");
const LOGS_TAG = '__logs_library__';
exports.version = require('../package').version;
class Library {
    constructor(name, settings) {
        this.name = name;
        let provider;
        if (typeof name === 'object') {
            provider = name;
            this.name = provider.name;
        }
        else if (name.match(/^\//)) {
            provider = require(name);
        }
        else if (fs.existsSync(__dirname + '/providers/' + name + '.js')) {
            provider = require('./providers/' + name);
        }
        else {
            try {
                provider = require('logs-' + name);
            }
            catch (e) {
                console.log('\nWARNING: Logs provider "' + name + '" is not installed,\nso your logger would not work, to fix run:\n\n    npm install logs-' + name, '\n');
                return;
            }
        }
        provider.initialize(this, settings);
        return this;
    }
    setLevel(level) {
        return this.provider.setLevel && this.provider.setLevel(level);
    }
    ;
    get(name, color, categories, options) {
        name = name || '[NONAME]';
        if (color && utils_1.isPlainObject(color)) {
            options = color;
        }
        else if (categories && utils_1.isPlainObject(categories)) {
            options = categories;
            categories = undefined;
        }
        categories = categories ? categories.slice() : [];
        options = options || {};
        const nativeLogger = this.provider.getLogger(name, options);
        return new adaptable_1.AdaptableLogger(nativeLogger, (name, color) => {
            return this.get(name, color, categories, Object.assign(Object.assign({}, options), { parent: nativeLogger }));
        });
    }
    ;
    middleware(opts) {
        if (this.provider.middleware) {
            return this.provider.middleware(opts);
        }
        return (req, res, next) => next();
    }
    ;
}
exports.Library = Library;
function use(name, settings, showUsingLogs) {
    const library = global[LOGS_TAG] = new Library(name, settings);
    if (showUsingLogs) {
        console.log('logs is using logging library "' + library.name + '"');
    }
    return module.exports;
}
exports.use = use;
function setLevel(level) {
    return global[LOGS_TAG] && global[LOGS_TAG].setLevel(level);
}
exports.setLevel = setLevel;
function get(name, color, category, colors, options) {
    if (!(LOGS_TAG in global)) {
        console.warn('[logs] NO LOG BRIDGE DEFINED. USING DEFAULT "CONSOLE" BRIDGE.');
        use('console');
    }
    return global[LOGS_TAG].get(name, color, category, colors, options);
}
exports.get = get;
//# sourceMappingURL=logs.js.map